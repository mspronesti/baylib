\hypertarget{adaptive__importance__sampling_8hpp_source}{}\doxysection{adaptive\+\_\+importance\+\_\+sampling.\+hpp}
\label{adaptive__importance__sampling_8hpp_source}\index{/home/mspronesti/Desktop/baylib/baylib/inference/adaptive\_importance\_sampling.hpp@{/home/mspronesti/Desktop/baylib/baylib/inference/adaptive\_importance\_sampling.hpp}}
\mbox{\hyperlink{adaptive__importance__sampling_8hpp}{Go to the documentation of this file.}}
\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{//}}
\DoxyCodeLine{2 \textcolor{comment}{// Created by paolo on 11/09/21.}}
\DoxyCodeLine{3 \textcolor{comment}{//}}
\DoxyCodeLine{4 }
\DoxyCodeLine{5 \textcolor{preprocessor}{\#ifndef BAYLIB\_ADAPTIVE\_IMPORTANCE\_SAMPLING\_HPP}}
\DoxyCodeLine{6 \textcolor{preprocessor}{\#define BAYLIB\_ADAPTIVE\_IMPORTANCE\_SAMPLING\_HPP}}
\DoxyCodeLine{7 }
\DoxyCodeLine{8 \textcolor{preprocessor}{\#define CL\_TARGET\_OPENCL\_VERSION 220}}
\DoxyCodeLine{9 }
\DoxyCodeLine{10 \textcolor{preprocessor}{\#include <\mbox{\hyperlink{abstract__inference__algorithm_8hpp}{inference/abstract\_inference\_algorithm.hpp}}>}}
\DoxyCodeLine{11 \textcolor{preprocessor}{\#include <\mbox{\hyperlink{icpt_8hpp}{probability/icpt.hpp}}>}}
\DoxyCodeLine{12 \textcolor{preprocessor}{\#include <\mbox{\hyperlink{cpt_8hpp}{probability/cpt.hpp}}>}}
\DoxyCodeLine{13 \textcolor{preprocessor}{\#include <boost/iterator/counting\_iterator.hpp>}}
\DoxyCodeLine{14 \textcolor{preprocessor}{\#include <boost/compute.hpp>}}
\DoxyCodeLine{15 \textcolor{preprocessor}{\#include <boost/compute/device.hpp>}}
\DoxyCodeLine{16 \textcolor{preprocessor}{\#include <utility>}}
\DoxyCodeLine{17 \textcolor{preprocessor}{\#include <execution>}}
\DoxyCodeLine{18 \textcolor{preprocessor}{\#include <\mbox{\hyperlink{gpu__utils_8hpp}{tools/gpu/gpu\_utils.hpp}}>}}
\DoxyCodeLine{19 \textcolor{preprocessor}{\#include <\mbox{\hyperlink{bayesian__utils_8hpp}{network/bayesian\_utils.hpp}}>}}
\DoxyCodeLine{20 }
\DoxyCodeLine{23 }
\DoxyCodeLine{24 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespacebn}{bn}} \{}
\DoxyCodeLine{25     \textcolor{keyword}{namespace }inference\{}
\DoxyCodeLine{26 }
\DoxyCodeLine{47         \textcolor{keyword}{template} <}
\DoxyCodeLine{48                 BNetDerived Network\_,}
\DoxyCodeLine{49                 \textcolor{keyword}{typename} Generator\_ = std::mt19937}
\DoxyCodeLine{50                 >}
\DoxyCodeLine{51         \textcolor{keyword}{class }\mbox{\hyperlink{classbn_1_1inference_1_1adaptive__importance__sampling}{adaptive\_importance\_sampling}}: \textcolor{keyword}{public} \mbox{\hyperlink{classbn_1_1inference_1_1vectorized__inference__algorithm}{vectorized\_inference\_algorithm}}<Network\_>}
\DoxyCodeLine{52         \{}
\DoxyCodeLine{53             \textcolor{keyword}{using} \textcolor{keyword}{typename} vectorized\_inference\_algorithm<Network\_>::network\_type;}
\DoxyCodeLine{54             \textcolor{keyword}{using} \textcolor{keyword}{typename} vectorized\_inference\_algorithm<Network\_>::probability\_type;}
\DoxyCodeLine{55             \textcolor{keyword}{using} \mbox{\hyperlink{classbn_1_1inference_1_1vectorized__inference__algorithm}{vectorized\_inference\_algorithm<Network\_>::bn}};}
\DoxyCodeLine{56             \textcolor{keyword}{typedef} std::vector<cow::icpt<probability\_type>> icpt\_vector;}
\DoxyCodeLine{57             \textcolor{keyword}{typedef} std::vector<std::vector<uint>>  simulation\_matrix;}
\DoxyCodeLine{58 }
\DoxyCodeLine{59         \textcolor{keyword}{public}:}
\DoxyCodeLine{60 }
\DoxyCodeLine{72             \textcolor{keyword}{explicit} \mbox{\hyperlink{classbn_1_1inference_1_1adaptive__importance__sampling_a98dc105271c6b04c2b23d47c057d6f04}{adaptive\_importance\_sampling}}(}
\DoxyCodeLine{73                 ulong nsamples,}
\DoxyCodeLine{74                 \textcolor{keywordtype}{size\_t} memory,}
\DoxyCodeLine{75                 \textcolor{keywordtype}{double} initial\_learning\_rate = 1,}
\DoxyCodeLine{76                 \textcolor{keywordtype}{double} final\_learning\_rate = 0.05,}
\DoxyCodeLine{77                 uint learning\_step = 1000,}
\DoxyCodeLine{78                 uint seed = 0,}
\DoxyCodeLine{79                 \textcolor{keyword}{const} compute::device\& device = compute::system::default\_device()}
\DoxyCodeLine{80             )}
\DoxyCodeLine{81             : \mbox{\hyperlink{classbn_1_1inference_1_1vectorized__inference__algorithm}{vectorized\_inference\_algorithm}}<Network\_>(nsamples, memory, seed, device)}
\DoxyCodeLine{82             , w\_k(1)}
\DoxyCodeLine{83             , initial\_learning\_rate(initial\_learning\_rate)}
\DoxyCodeLine{84             , final\_learning\_rate(final\_learning\_rate)}
\DoxyCodeLine{85             , learning\_cutoff(0.005)}
\DoxyCodeLine{86             , learning\_step(learning\_step)\{\}}
\DoxyCodeLine{87 }
\DoxyCodeLine{95             \mbox{\hyperlink{classbn_1_1marginal__distribution}{bn::marginal\_distribution<probability\_type>}} \mbox{\hyperlink{classbn_1_1inference_1_1inference__algorithm_a4f17b6c28949271183deef002c28e7a2}{make\_inference}} ()}
\DoxyCodeLine{96             \{}
\DoxyCodeLine{97                 BAYLIB\_ASSERT(std::all\_of(\mbox{\hyperlink{namespacebn}{bn}}.begin(), \mbox{\hyperlink{namespacebn}{bn}}.end(),}
\DoxyCodeLine{98                                           [\textcolor{keyword}{this}](\textcolor{keyword}{auto} \&var)\{ return bn::cpt\_filled\_out(bn, var.id()); \}),}
\DoxyCodeLine{99                               \textcolor{stringliteral}{"{}conditional probability tables must be properly filled to"{}}}
\DoxyCodeLine{100                               \textcolor{stringliteral}{"{} run logic\_sampling inference algorithm"{}},}
\DoxyCodeLine{101                               std::runtime\_error);}
\DoxyCodeLine{102 }
\DoxyCodeLine{103                 icpt\_vector icptvec\{\};}
\DoxyCodeLine{104                 \textcolor{keyword}{auto} result = \mbox{\hyperlink{classbn_1_1marginal__distribution}{marginal\_distribution<probability\_type>}}(\mbox{\hyperlink{namespacebn}{bn}}.begin(), \mbox{\hyperlink{namespacebn}{bn}}.end());}
\DoxyCodeLine{105                 \textcolor{keywordtype}{bool} evidence\_found = \textcolor{keyword}{false};}
\DoxyCodeLine{106                 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} v\_id = 0; v\_id < \mbox{\hyperlink{namespacebn}{bn}}.number\_of\_variables(); ++v\_id)\{}
\DoxyCodeLine{107                     icptvec.emplace\_back(\mbox{\hyperlink{classbn_1_1cow_1_1icpt}{cow::icpt<probability\_type>}}(\mbox{\hyperlink{namespacebn}{bn}}[v\_id].table()));}
\DoxyCodeLine{108                     \textcolor{keywordflow}{if}(\mbox{\hyperlink{namespacebn}{bn}}[v\_id].is\_evidence())\{}
\DoxyCodeLine{109                         result[v\_id][\mbox{\hyperlink{namespacebn}{bn}}[v\_id].evidence\_state()] = 1;}
\DoxyCodeLine{110                         evidence\_found = \textcolor{keyword}{true};}
\DoxyCodeLine{111                     \}}
\DoxyCodeLine{112                 \}}
\DoxyCodeLine{113                 \textcolor{comment}{// If no evidence is present the algorithm degenerates to simple}}
\DoxyCodeLine{114                 \textcolor{comment}{// logic\_sampling, and we can skip the learning phase}}
\DoxyCodeLine{115                 \textcolor{keywordflow}{if}(evidence\_found)\{}
\DoxyCodeLine{116                     ancestors = \mbox{\hyperlink{namespacebn_a458aec071117b23c396cd2bddc27bc58}{ancestors\_of\_evidence}}(\mbox{\hyperlink{namespacebn}{bn}});}
\DoxyCodeLine{117                     learn\_icpt(icptvec);}
\DoxyCodeLine{118                 \}}
\DoxyCodeLine{119                 result += gpu\_simulation(icptvec, \mbox{\hyperlink{namespacebn}{bn}});}
\DoxyCodeLine{120                 result.normalize();}
\DoxyCodeLine{121                 \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{122             \}}
\DoxyCodeLine{123 }
\DoxyCodeLine{124 }
\DoxyCodeLine{125         \textcolor{keyword}{private}:}
\DoxyCodeLine{126             \textcolor{keywordtype}{double} w\_k;}
\DoxyCodeLine{127             std::vector<ulong> ancestors;}
\DoxyCodeLine{128             \textcolor{keywordtype}{double} initial\_learning\_rate;}
\DoxyCodeLine{129             \textcolor{keywordtype}{double} final\_learning\_rate;}
\DoxyCodeLine{130             \textcolor{keywordtype}{double} learning\_cutoff;}
\DoxyCodeLine{131             uint learning\_step;}
\DoxyCodeLine{132 }
\DoxyCodeLine{133 }
\DoxyCodeLine{148             \textcolor{keywordtype}{void} learn\_icpt( icpt\_vector \& icptvec )}
\DoxyCodeLine{149             \{}
\DoxyCodeLine{150                 ulong nvars = \mbox{\hyperlink{namespacebn}{bn}}.number\_of\_variables();}
\DoxyCodeLine{151                 simulation\_matrix graph\_state(learning\_step);}
\DoxyCodeLine{152                 std::vector<probability\_type> random\_vec(learning\_step * nvars);}
\DoxyCodeLine{153                 \textcolor{keywordtype}{double} k = 0;}
\DoxyCodeLine{154                 uint max\_k = this-\/>nsamples / 2 / learning\_step;}
\DoxyCodeLine{155                 seed\_factory factory(1, this-\/>seed);}
\DoxyCodeLine{156                 \mbox{\hyperlink{classbn_1_1random__generator}{bn::random\_generator<probability\_type, Generator\_>}} rnd\_gen(this-\/>seed);}
\DoxyCodeLine{157 }
\DoxyCodeLine{158                 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < max\_k; ++i) \{}
\DoxyCodeLine{159                     std::future<void> el = std::async([\&]()\{std::generate(}
\DoxyCodeLine{160                                                 random\_vec.begin(),}
\DoxyCodeLine{161                                                 random\_vec.end(),}
\DoxyCodeLine{162                                                 rnd\_gen);\});}
\DoxyCodeLine{163                     \textcolor{keywordflow}{if}(i != 0)\{}
\DoxyCodeLine{164                         \textcolor{comment}{// Formula for the learning\_rate proposed in the paper}}
\DoxyCodeLine{165                         \textcolor{keywordtype}{double} learning\_rate = initial\_learning\_rate *}
\DoxyCodeLine{166                                 std::pow(final\_learning\_rate / initial\_learning\_rate,k / (\textcolor{keywordtype}{double})max\_k);}
\DoxyCodeLine{167                         \textcolor{keywordtype}{double} difference = absorb\_samples(graph\_state, \mbox{\hyperlink{namespacebn}{bn}}, icptvec, learning\_rate);}
\DoxyCodeLine{168                         \textcolor{comment}{// if the maximum difference was low enough we stop the learning process}}
\DoxyCodeLine{169                         \textcolor{keywordflow}{if}(difference < learning\_cutoff)\{}
\DoxyCodeLine{170                             \textcolor{keywordflow}{break};}
\DoxyCodeLine{171                         \}}
\DoxyCodeLine{172                         k++;}
\DoxyCodeLine{173                     \}}
\DoxyCodeLine{174                     el.get();}
\DoxyCodeLine{175 }
\DoxyCodeLine{176                     std::transform( std::execution::par,}
\DoxyCodeLine{177                                     boost::counting\_iterator<ulong>(0),}
\DoxyCodeLine{178                                     boost::counting\_iterator<ulong>(graph\_state.size()),}
\DoxyCodeLine{179                                     graph\_state.begin(),}
\DoxyCodeLine{180                                     [\&](ulong ix)}
\DoxyCodeLine{181                                     \{}
\DoxyCodeLine{182                                     std::vector<uint> local\_result(nvars);}
\DoxyCodeLine{183                                     ix *= nvars;}
\DoxyCodeLine{184                                     for (ulong v: ancestors) \{}
\DoxyCodeLine{185                                         if (bn[v].is\_evidence()) \{}
\DoxyCodeLine{186                                             local\_result[v] = bn[v].evidence\_state();}
\DoxyCodeLine{187                                             continue;}
\DoxyCodeLine{188                                         \}}
\DoxyCodeLine{189                                         const probability\_type p = random\_vec[ix];}
\DoxyCodeLine{190                                         ix++;}
\DoxyCodeLine{191                                         std::vector<probability\_type> weight;}
\DoxyCodeLine{192                                         bn::condition parents\_state\_cond;}
\DoxyCodeLine{193                                         for (auto par : bn.parents\_of(v))}
\DoxyCodeLine{194                                             parents\_state\_cond.add(}
\DoxyCodeLine{195                                                     par,}
\DoxyCodeLine{196                                                     local\_result[par]}
\DoxyCodeLine{197                                                     );}
\DoxyCodeLine{198                                         weight = icptvec[v][parents\_state\_cond];}
\DoxyCodeLine{199                                         ulong sample = make\_random\_by\_weight(p, weight);}
\DoxyCodeLine{200                                         local\_result[v] = sample;}
\DoxyCodeLine{201                                     \}}
\DoxyCodeLine{202                                     \textcolor{keywordflow}{return} local\_result;}
\DoxyCodeLine{203                                     \});}
\DoxyCodeLine{204                 \}}
\DoxyCodeLine{205                 this-\/>seed = factory.get\_new(); \textcolor{comment}{// new seed for gpu simulation}}
\DoxyCodeLine{206             \}}
\DoxyCodeLine{207 }
\DoxyCodeLine{208 }
\DoxyCodeLine{217             \textcolor{keywordtype}{double} absorb\_samples(}
\DoxyCodeLine{218                 \textcolor{keyword}{const} simulation\_matrix \& graph\_state,}
\DoxyCodeLine{219                 \textcolor{keyword}{const} network\_type \& \mbox{\hyperlink{namespacebn}{bn}},}
\DoxyCodeLine{220                 icpt\_vector \& icptvec,}
\DoxyCodeLine{221                 \textcolor{keywordtype}{double} learning\_rate}
\DoxyCodeLine{222             )}
\DoxyCodeLine{223             \{}
\DoxyCodeLine{224                 probability\_type evidence\_score;}
\DoxyCodeLine{225                 std::vector<probability\_type> sample\_weight(graph\_state.size());}
\DoxyCodeLine{226 }
\DoxyCodeLine{227                 \textcolor{keywordtype}{double} max\_distance = 0.;}
\DoxyCodeLine{228 }
\DoxyCodeLine{229                 \textcolor{comment}{// Calculate the likelihood of extracting a particular set of samples}}
\DoxyCodeLine{230                 std::transform(std::execution::par\_unseq,}
\DoxyCodeLine{231                                boost::counting\_iterator<uint>(0),}
\DoxyCodeLine{232                                boost::counting\_iterator<uint>(graph\_state.size()),}
\DoxyCodeLine{233                                sample\_weight.begin(),}
\DoxyCodeLine{234                                [\&](uint ix)}
\DoxyCodeLine{235                                \{}
\DoxyCodeLine{236                                 probability\_type weight = 1;}
\DoxyCodeLine{237                                 for(ulong v\_id: ancestors)\{}
\DoxyCodeLine{238                                     condition cond;}
\DoxyCodeLine{239                                     auto\& icpt = icptvec[v\_id];}
\DoxyCodeLine{240                                     auto\& cpt = bn[v\_id].table();}
\DoxyCodeLine{241                                     auto\& sample\_state = graph\_state[ix][v\_id];}
\DoxyCodeLine{242 }
\DoxyCodeLine{243                                     for(auto p\_id : bn.parents\_of(v\_id))}
\DoxyCodeLine{244                                         cond.add(p\_id, graph\_state[ix][p\_id]);}
\DoxyCodeLine{245                                     if(bn[v\_id].is\_evidence())\{}
\DoxyCodeLine{246                                         weight *= cpt[cond][bn[v\_id].evidence\_state()];}
\DoxyCodeLine{247                                     \}else\{}
\DoxyCodeLine{248                                         weight *= cpt[cond][sample\_state] / icpt[cond][sample\_state];}
\DoxyCodeLine{249                                     \}}
\DoxyCodeLine{250                                 \}}
\DoxyCodeLine{251                                 \textcolor{keywordflow}{return}  weight;\});}
\DoxyCodeLine{252 }
\DoxyCodeLine{253                 \textcolor{comment}{// Update the icpts and return the maximum distance}}
\DoxyCodeLine{254                 max\_distance =  std::transform\_reduce(}
\DoxyCodeLine{255                                 std::execution::par\_unseq,}
\DoxyCodeLine{256                                 ancestors.begin(),}
\DoxyCodeLine{257                                 ancestors.end(),}
\DoxyCodeLine{258                                 0.,}
\DoxyCodeLine{259                                 [](\textcolor{keyword}{auto} e1, \textcolor{keyword}{auto} e2)\{return e1 > e2 ? e1 : e2;\},}
\DoxyCodeLine{260                                 [\&](\textcolor{keyword}{auto} v\_id)}
\DoxyCodeLine{261                                 \{}
\DoxyCodeLine{262                                     if(bn[v\_id].is\_evidence())}
\DoxyCodeLine{263                                         return 0.;}
\DoxyCodeLine{264                                     auto\& original\_cpt = icptvec[v\_id];}
\DoxyCodeLine{265                                     cow::icpt<probability\_type> temp\_icpt(bn[v\_id].table(), true);}
\DoxyCodeLine{266                                     for (int i = 0; i < graph\_state.size(); ++i) \{}
\DoxyCodeLine{267                                         condition cond;}
\DoxyCodeLine{268                                         auto sample = graph\_state[i][v\_id];}
\DoxyCodeLine{269                                         for(auto p\_id : bn.parents\_of(v\_id))}
\DoxyCodeLine{270                                             cond.add(p\_id, graph\_state[i][p\_id]);}
\DoxyCodeLine{271                                         temp\_icpt[cond][sample] += sample\_weight[i];}
\DoxyCodeLine{272                                     \}}
\DoxyCodeLine{273                                     temp\_icpt.normalize();}
\DoxyCodeLine{274                                     \textcolor{keywordtype}{double} distance = original\_cpt.absorb(temp\_icpt, learning\_rate);}
\DoxyCodeLine{275                                     \textcolor{keywordflow}{return} distance;}
\DoxyCodeLine{276                                 \});}
\DoxyCodeLine{277 }
\DoxyCodeLine{278                 \textcolor{keywordflow}{return} max\_distance;}
\DoxyCodeLine{279             \}}
\DoxyCodeLine{280 }
\DoxyCodeLine{288             marginal\_distribution<probability\_type> gpu\_simulation(}
\DoxyCodeLine{289                     \textcolor{keyword}{const} icpt\_vector\& icpt\_vec,}
\DoxyCodeLine{290                     \textcolor{keyword}{const} network\_type \& \mbox{\hyperlink{namespacebn}{bn}}}
\DoxyCodeLine{291             )}
\DoxyCodeLine{292             \{}
\DoxyCodeLine{293                 \textcolor{keywordtype}{int} niter = 1;}
\DoxyCodeLine{294                 marginal\_distribution<probability\_type> marginal\_result(\mbox{\hyperlink{namespacebn}{bn}}.begin(), \mbox{\hyperlink{namespacebn}{bn}}.end());}
\DoxyCodeLine{295                 std::vector<bcvec> result\_container(\mbox{\hyperlink{namespacebn}{bn}}.number\_of\_variables());}
\DoxyCodeLine{296                 marginal\_distribution<probability\_type> temp(\mbox{\hyperlink{namespacebn}{bn}}.begin(), \mbox{\hyperlink{namespacebn}{bn}}.end());}
\DoxyCodeLine{297                 \textcolor{keyword}{auto} [gpu\_samples, gpu\_iter] = this-\/>calculate\_iterations(\mbox{\hyperlink{namespacebn}{bn}});}
\DoxyCodeLine{298 }
\DoxyCodeLine{299                 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < gpu\_iter; ++i)\{}
\DoxyCodeLine{300                     \textcolor{keywordflow}{for}(ulong v : \mbox{\hyperlink{namespacebn_af3d46b351f924835802c271a247183b5}{sampling\_order}}(\mbox{\hyperlink{namespacebn}{bn}})) \{}
\DoxyCodeLine{301                         \textcolor{keywordflow}{if}(\mbox{\hyperlink{namespacebn}{bn}}[v].is\_evidence())\{}
\DoxyCodeLine{302                             result\_container[v] = bcvec(this-\/>nsamples, \mbox{\hyperlink{namespacebn}{bn}}[v].number\_of\_states(), this-\/>context);}
\DoxyCodeLine{303                             compute::fill(result\_container[v].state.begin(), result\_container[v].state.end(), \mbox{\hyperlink{namespacebn}{bn}}[v].evidence\_state(), this-\/>queue);}
\DoxyCodeLine{304                         \}}
\DoxyCodeLine{305                         \textcolor{keywordflow}{else}\{}
\DoxyCodeLine{306                             std::vector<bcvec*> parents\_result;}
\DoxyCodeLine{307                             \textcolor{keyword}{auto} parents = \mbox{\hyperlink{namespacebn}{bn}}.parents\_of(v);}
\DoxyCodeLine{308                             std::reverse(parents.begin(), parents.end());}
\DoxyCodeLine{309                             \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} p : parents) \{}
\DoxyCodeLine{310                                 parents\_result.push\_back(\&result\_container[p]);}
\DoxyCodeLine{311                             \}}
\DoxyCodeLine{312 }
\DoxyCodeLine{313                             result\_container[v] = this-\/>simulate\_node(icpt\_vec[v] , parents\_result, gpu\_samples);}
\DoxyCodeLine{314 }
\DoxyCodeLine{315                             \textcolor{keyword}{auto} accumulated\_result = compute\_result\_general(result\_container[v]);}
\DoxyCodeLine{316 }
\DoxyCodeLine{317                             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} ix=0; ix< accumulated\_result.size(); ix++)}
\DoxyCodeLine{318                                 marginal\_result[v][ix] += accumulated\_result[ix];}
\DoxyCodeLine{319                         \}}
\DoxyCodeLine{320                     \}}
\DoxyCodeLine{321                 \}}
\DoxyCodeLine{322                 \textcolor{keywordflow}{return} marginal\_result;}
\DoxyCodeLine{323             \}}
\DoxyCodeLine{324 }
\DoxyCodeLine{330             std::vector<ulong> compute\_result\_general(bcvec\& res)}
\DoxyCodeLine{331             \{}
\DoxyCodeLine{332                 std::vector<ulong> acc\_res(res.cardinality);}
\DoxyCodeLine{333                 \textcolor{keywordflow}{for} (bn::state\_t i = 0; i < res.cardinality; ++i) \{}
\DoxyCodeLine{334                     acc\_res[i] = w\_k * compute::count(res.state.begin(), res.state.end(), i, this-\/>queue);}
\DoxyCodeLine{335                 \}}
\DoxyCodeLine{336                 \textcolor{keywordflow}{return} acc\_res;}
\DoxyCodeLine{337             \}}
\DoxyCodeLine{338 }
\DoxyCodeLine{339 }
\DoxyCodeLine{346             uint make\_random\_by\_weight(}
\DoxyCodeLine{347                 \textcolor{keyword}{const} probability\_type p,}
\DoxyCodeLine{348                 \textcolor{keyword}{const} std::vector<probability\_type> \& weight}
\DoxyCodeLine{349             )}
\DoxyCodeLine{350             \{}
\DoxyCodeLine{351                 probability\_type total = 0.0;}
\DoxyCodeLine{352                 \textcolor{keywordflow}{for}(uint i = 0; i < weight.size(); ++i)}
\DoxyCodeLine{353                 \{}
\DoxyCodeLine{354                     \textcolor{keyword}{auto} \textcolor{keyword}{const} old\_total = total;}
\DoxyCodeLine{355                     total += weight[i];}
\DoxyCodeLine{356                     \textcolor{keywordflow}{if}(old\_total <= p \&\& p < total)}
\DoxyCodeLine{357                     \{}
\DoxyCodeLine{358                         \textcolor{keywordflow}{return} i;}
\DoxyCodeLine{359                     \}}
\DoxyCodeLine{360                 \}}
\DoxyCodeLine{361                 \textcolor{keywordflow}{return} weight.size() -\/ 1;}
\DoxyCodeLine{362             \}}
\DoxyCodeLine{363         \};}
\DoxyCodeLine{364     \}}
\DoxyCodeLine{365 \}}
\DoxyCodeLine{366 }
\DoxyCodeLine{367 \textcolor{preprocessor}{\#endif }\textcolor{comment}{//BAYLIB\_ADAPTIVE\_IMPORTANCE\_SAMPLING\_HPP}}

\end{DoxyCode}
