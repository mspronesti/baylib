\hypertarget{classthread__pool}{}\doxysection{thread\+\_\+pool Class Reference}
\label{classthread__pool}\index{thread\_pool@{thread\_pool}}


A C++17 thread pool class. The user submits tasks to be executed into a queue. Whenever a thread becomes available, it pops a task from the queue and executes it. Each task is automatically assigned a future, which can be used to wait for the task to finish executing and/or obtain its eventual return value.  




{\ttfamily \#include $<$thread\+\_\+pool.\+hpp$>$}

\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classthread__pool_afc887e2c84ebe8176ce44a9065d780b5}{thread\+\_\+pool}} (const ui32 \&\+\_\+thread\+\_\+count=std\+::thread\+::hardware\+\_\+concurrency())
\begin{DoxyCompactList}\small\item\em Construct a new thread pool. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classthread__pool_ac9d8f108fa2419441aba432f8ca98eae}\label{classthread__pool_ac9d8f108fa2419441aba432f8ca98eae}} 
{\bfseries $\sim$thread\+\_\+pool} ()
\begin{DoxyCompactList}\small\item\em Destruct the thread pool. Waits for all tasks to complete, then destroys all threads. Note that if the variable paused is set to true, then any tasks still in the queue will never be executed. \end{DoxyCompactList}\item 
size\+\_\+t \mbox{\hyperlink{classthread__pool_a88d94c6c8cdf115a9d2e7501d92aea31}{get\+\_\+tasks\+\_\+queued}} () const
\begin{DoxyCompactList}\small\item\em Get the number of tasks currently waiting in the queue to be executed by the threads. \end{DoxyCompactList}\item 
ui32 \mbox{\hyperlink{classthread__pool_af2b7074a626d50f846e75119421567f1}{get\+\_\+tasks\+\_\+running}} () const
\begin{DoxyCompactList}\small\item\em Get the number of tasks currently being executed by the threads. \end{DoxyCompactList}\item 
ui32 \mbox{\hyperlink{classthread__pool_ac2f208d87fb7cc624097b6316f65fac4}{get\+\_\+tasks\+\_\+total}} () const
\begin{DoxyCompactList}\small\item\em Get the total number of unfinished tasks -\/ either still in the queue, or running in a thread. \end{DoxyCompactList}\item 
ui32 \mbox{\hyperlink{classthread__pool_a9878745e655fa3db5c7c16af9766fc59}{get\+\_\+thread\+\_\+count}} () const
\begin{DoxyCompactList}\small\item\em Get the number of threads in the pool. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , typename F $>$ }\\void \mbox{\hyperlink{classthread__pool_affc0a6e9a59d7a2464ae4c454d4271a8}{parallelize\+\_\+loop}} (T first\+\_\+index, T last\+\_\+index, const F \&loop, ui32 num\+\_\+tasks=0)
\begin{DoxyCompactList}\small\item\em Parallelize a loop by splitting it into blocks, submitting each block separately to the thread pool, and waiting for all blocks to finish executing. The loop will be equivalent to\+: for (T i = first\+\_\+index; i \texorpdfstring{$<$}{<}= last\+\_\+index; i++) loop(i);. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename F $>$ }\\void \mbox{\hyperlink{classthread__pool_a3e9d8436b3eb525ae5fee597740a86f4}{push\+\_\+task}} (const F \&task)
\begin{DoxyCompactList}\small\item\em Push a function with no arguments or return value into the task queue. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename F , typename... A$>$ }\\void \mbox{\hyperlink{classthread__pool_ae37f7cf895480503583a852c30947794}{push\+\_\+task}} (const F \&task, const A \&...args)
\begin{DoxyCompactList}\small\item\em Push a function with arguments, but no return value, into the task queue. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classthread__pool_aa5926f83dde427afac052f4d72237b18}{reset}} (const ui32 \&\+\_\+thread\+\_\+count=std\+::thread\+::hardware\+\_\+concurrency())
\begin{DoxyCompactList}\small\item\em Reset the number of threads in the pool. Waits for all currently running tasks to be completed, then destroys all threads in the pool and creates a new thread pool with the new number of threads. Any tasks that were waiting in the queue before the pool was reset will then be executed by the new threads. If the pool was paused before resetting it, the new pool will be paused as well. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename F , typename... A, typename  = std\+::enable\+\_\+if\+\_\+t$<$std\+::is\+\_\+void\+\_\+v$<$std\+::invoke\+\_\+result\+\_\+t$<$std\+::decay\+\_\+t$<$\+F$>$, std\+::decay\+\_\+t$<$\+A$>$...$>$$>$$>$$>$ }\\std\+::future$<$ bool $>$ \mbox{\hyperlink{classthread__pool_a132ec56ca21d1517b6851ab6d798ee0f}{submit}} (const F \&task, const A \&...args)
\begin{DoxyCompactList}\small\item\em Submit a function with zero or more arguments and no return value into the task queue, and get an std\+::future$<$bool$>$ that will be set to true upon completion of the task. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename F , typename... A, typename R  = std\+::invoke\+\_\+result\+\_\+t$<$std\+::decay\+\_\+t$<$\+F$>$, std\+::decay\+\_\+t$<$\+A$>$...$>$, typename  = std\+::enable\+\_\+if\+\_\+t$<$!std\+::is\+\_\+void\+\_\+v$<$\+R$>$$>$$>$ }\\std\+::future$<$ R $>$ \mbox{\hyperlink{classthread__pool_a57c26beb0b0f6985b72ab98317ce9b09}{submit}} (const F \&task, const A \&...args)
\begin{DoxyCompactList}\small\item\em Submit a function with zero or more arguments and a return value into the task queue, and get a future for its eventual returned value. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classthread__pool_a887cef533635b8c52834b23be3ab1c68}\label{classthread__pool_a887cef533635b8c52834b23be3ab1c68}} 
void {\bfseries wait\+\_\+for\+\_\+tasks} ()
\begin{DoxyCompactList}\small\item\em Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are currently running in the threads and those that are still waiting in the queue. However, if the variable paused is set to true, this function only waits for the currently running tasks (otherwise it would wait forever). To wait for a specific task, use \mbox{\hyperlink{classthread__pool_a132ec56ca21d1517b6851ab6d798ee0f}{submit()}} instead, and call the wait() member function of the generated future. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Data Fields}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classthread__pool_a69128e62f8197d0ed578d6baa0553ce8}\label{classthread__pool_a69128e62f8197d0ed578d6baa0553ce8}} 
std\+::atomic$<$ bool $>$ {\bfseries paused} = false
\begin{DoxyCompactList}\small\item\em An atomic variable indicating to the workers to pause. When set to true, the workers temporarily stop popping new tasks out of the queue, although any tasks already executed will keep running until they are done. Set to false again to resume popping tasks. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classthread__pool_aa0bd5e834e1c8358cd24d2c5743b95a8}\label{classthread__pool_aa0bd5e834e1c8358cd24d2c5743b95a8}} 
ui32 {\bfseries sleep\+\_\+duration} = 1000
\begin{DoxyCompactList}\small\item\em The duration, in microseconds, that the worker function should sleep for when it cannot find any tasks in the queue. If set to 0, then instead of sleeping, the worker function will execute std\+::this\+\_\+thread\+::yield() if there are no tasks in the queue. The default value is 1000. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Private Types}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classthread__pool_a9a54befa558b9d426a5ef18118de6185}\label{classthread__pool_a9a54befa558b9d426a5ef18118de6185}} 
typedef std\+::uint\+\_\+fast32\+\_\+t {\bfseries ui32}
\end{DoxyCompactItemize}
\doxysubsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classthread__pool_a9c1e1a00bf0f12c5e4c1422d5eadca94}\label{classthread__pool_a9c1e1a00bf0f12c5e4c1422d5eadca94}} 
void {\bfseries create\+\_\+threads} ()
\begin{DoxyCompactList}\small\item\em Create the threads in the pool and assign a worker to each thread. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classthread__pool_a7ceb7a2d9745499649a4e32ea5fcb72b}\label{classthread__pool_a7ceb7a2d9745499649a4e32ea5fcb72b}} 
void {\bfseries destroy\+\_\+threads} ()
\begin{DoxyCompactList}\small\item\em Destroy the threads in the pool by joining them. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classthread__pool_aa156bf8fb5803cb0e56b4b5f4f6f2010}{pop\+\_\+task}} (std\+::function$<$ void()$>$ \&task)
\begin{DoxyCompactList}\small\item\em Try to pop a new task out of the queue. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classthread__pool_afc980adc973c19cb64857b34e4759866}\label{classthread__pool_afc980adc973c19cb64857b34e4759866}} 
void {\bfseries sleep\+\_\+or\+\_\+yield} ()
\begin{DoxyCompactList}\small\item\em Sleep for sleep\+\_\+duration microseconds. If that variable is set to zero, yield instead. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classthread__pool_a38b0cb91a6f87146fd8c194b3ee87638}\label{classthread__pool_a38b0cb91a6f87146fd8c194b3ee87638}} 
void {\bfseries worker} ()
\begin{DoxyCompactList}\small\item\em A worker function to be assigned to each thread in the pool. Continuously pops tasks out of the queue and executes them, as long as the atomic variable running is set to true. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classthread__pool_afdf641af037cd483998f0f830d7db21f}\label{classthread__pool_afdf641af037cd483998f0f830d7db21f}} 
std\+::mutex {\bfseries queue\+\_\+mutex}
\begin{DoxyCompactList}\small\item\em A mutex to synchronize access to the task queue by different threads. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classthread__pool_a25218460dba3f28dd14cade108ccbaa1}\label{classthread__pool_a25218460dba3f28dd14cade108ccbaa1}} 
std\+::atomic$<$ bool $>$ {\bfseries running} = true
\begin{DoxyCompactList}\small\item\em An atomic variable indicating to the workers to keep running. When set to false, the workers permanently stop working. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classthread__pool_a0aef9354f74dba9b469084ba17feb5e1}\label{classthread__pool_a0aef9354f74dba9b469084ba17feb5e1}} 
std\+::queue$<$ std\+::function$<$ void()$>$ $>$ {\bfseries tasks}
\begin{DoxyCompactList}\small\item\em A queue of tasks to be executed by the threads. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classthread__pool_a4eb87a055bf8762d9a6186d06db2730f}\label{classthread__pool_a4eb87a055bf8762d9a6186d06db2730f}} 
ui32 {\bfseries thread\+\_\+count}
\begin{DoxyCompactList}\small\item\em The number of threads in the pool. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classthread__pool_a59c590c4b97bb05c59c22c40bbac43ed}\label{classthread__pool_a59c590c4b97bb05c59c22c40bbac43ed}} 
std\+::unique\+\_\+ptr$<$ std\+::thread\mbox{[}$\,$\mbox{]}$>$ {\bfseries threads}
\begin{DoxyCompactList}\small\item\em A smart pointer to manage the memory allocated for the threads. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classthread__pool_aaadd54679f33196ff289db30604a0032}\label{classthread__pool_aaadd54679f33196ff289db30604a0032}} 
std\+::atomic$<$ ui32 $>$ {\bfseries tasks\+\_\+total} = 0
\begin{DoxyCompactList}\small\item\em An atomic variable to keep track of the total number of unfinished tasks -\/ either still in the queue, or running in a thread. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
A C++17 thread pool class. The user submits tasks to be executed into a queue. Whenever a thread becomes available, it pops a task from the queue and executes it. Each task is automatically assigned a future, which can be used to wait for the task to finish executing and/or obtain its eventual return value. 

\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classthread__pool_afc887e2c84ebe8176ce44a9065d780b5}\label{classthread__pool_afc887e2c84ebe8176ce44a9065d780b5}} 
\index{thread\_pool@{thread\_pool}!thread\_pool@{thread\_pool}}
\index{thread\_pool@{thread\_pool}!thread\_pool@{thread\_pool}}
\doxysubsubsection{\texorpdfstring{thread\_pool()}{thread\_pool()}}
{\footnotesize\ttfamily thread\+\_\+pool\+::thread\+\_\+pool (\begin{DoxyParamCaption}\item[{const ui32 \&}]{\+\_\+thread\+\_\+count = {\ttfamily std\+:\+:thread\+:\+:hardware\+\_\+concurrency()} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}



Construct a new thread pool. 


\begin{DoxyParams}{Parameters}
{\em \+\_\+thread\+\_\+count} & The number of threads to use. The default value is the total number of hardware threads available, as reported by the implementation. With a hyperthreaded CPU, this will be twice the number of CPU cores. If the argument is zero, the default value will be used instead. \\
\hline
\end{DoxyParams}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classthread__pool_a88d94c6c8cdf115a9d2e7501d92aea31}\label{classthread__pool_a88d94c6c8cdf115a9d2e7501d92aea31}} 
\index{thread\_pool@{thread\_pool}!get\_tasks\_queued@{get\_tasks\_queued}}
\index{get\_tasks\_queued@{get\_tasks\_queued}!thread\_pool@{thread\_pool}}
\doxysubsubsection{\texorpdfstring{get\_tasks\_queued()}{get\_tasks\_queued()}}
{\footnotesize\ttfamily size\+\_\+t thread\+\_\+pool\+::get\+\_\+tasks\+\_\+queued (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Get the number of tasks currently waiting in the queue to be executed by the threads. 

\begin{DoxyReturn}{Returns}
The number of queued tasks. 
\end{DoxyReturn}
\mbox{\Hypertarget{classthread__pool_af2b7074a626d50f846e75119421567f1}\label{classthread__pool_af2b7074a626d50f846e75119421567f1}} 
\index{thread\_pool@{thread\_pool}!get\_tasks\_running@{get\_tasks\_running}}
\index{get\_tasks\_running@{get\_tasks\_running}!thread\_pool@{thread\_pool}}
\doxysubsubsection{\texorpdfstring{get\_tasks\_running()}{get\_tasks\_running()}}
{\footnotesize\ttfamily ui32 thread\+\_\+pool\+::get\+\_\+tasks\+\_\+running (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Get the number of tasks currently being executed by the threads. 

\begin{DoxyReturn}{Returns}
The number of running tasks. 
\end{DoxyReturn}
\mbox{\Hypertarget{classthread__pool_ac2f208d87fb7cc624097b6316f65fac4}\label{classthread__pool_ac2f208d87fb7cc624097b6316f65fac4}} 
\index{thread\_pool@{thread\_pool}!get\_tasks\_total@{get\_tasks\_total}}
\index{get\_tasks\_total@{get\_tasks\_total}!thread\_pool@{thread\_pool}}
\doxysubsubsection{\texorpdfstring{get\_tasks\_total()}{get\_tasks\_total()}}
{\footnotesize\ttfamily ui32 thread\+\_\+pool\+::get\+\_\+tasks\+\_\+total (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Get the total number of unfinished tasks -\/ either still in the queue, or running in a thread. 

\begin{DoxyReturn}{Returns}
The total number of tasks. 
\end{DoxyReturn}
\mbox{\Hypertarget{classthread__pool_a9878745e655fa3db5c7c16af9766fc59}\label{classthread__pool_a9878745e655fa3db5c7c16af9766fc59}} 
\index{thread\_pool@{thread\_pool}!get\_thread\_count@{get\_thread\_count}}
\index{get\_thread\_count@{get\_thread\_count}!thread\_pool@{thread\_pool}}
\doxysubsubsection{\texorpdfstring{get\_thread\_count()}{get\_thread\_count()}}
{\footnotesize\ttfamily ui32 thread\+\_\+pool\+::get\+\_\+thread\+\_\+count (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Get the number of threads in the pool. 

\begin{DoxyReturn}{Returns}
The number of threads. 
\end{DoxyReturn}
\mbox{\Hypertarget{classthread__pool_affc0a6e9a59d7a2464ae4c454d4271a8}\label{classthread__pool_affc0a6e9a59d7a2464ae4c454d4271a8}} 
\index{thread\_pool@{thread\_pool}!parallelize\_loop@{parallelize\_loop}}
\index{parallelize\_loop@{parallelize\_loop}!thread\_pool@{thread\_pool}}
\doxysubsubsection{\texorpdfstring{parallelize\_loop()}{parallelize\_loop()}}
{\footnotesize\ttfamily template$<$typename T , typename F $>$ \\
void thread\+\_\+pool\+::parallelize\+\_\+loop (\begin{DoxyParamCaption}\item[{T}]{first\+\_\+index,  }\item[{T}]{last\+\_\+index,  }\item[{const F \&}]{loop,  }\item[{ui32}]{num\+\_\+tasks = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Parallelize a loop by splitting it into blocks, submitting each block separately to the thread pool, and waiting for all blocks to finish executing. The loop will be equivalent to\+: for (T i = first\+\_\+index; i \texorpdfstring{$<$}{<}= last\+\_\+index; i++) loop(i);. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & The type of the loop index. Should be a signed or unsigned integer. \\
\hline
{\em F} & The type of the function to loop through. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em first\+\_\+index} & The first index in the loop (inclusive). \\
\hline
{\em last\+\_\+index} & The last index in the loop (inclusive). \\
\hline
{\em loop} & The function to loop through. Should take exactly one argument, the loop index. \\
\hline
{\em num\+\_\+tasks} & The maximum number of tasks to split the loop into. The default is to use the number of threads in the pool. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classthread__pool_aa156bf8fb5803cb0e56b4b5f4f6f2010}\label{classthread__pool_aa156bf8fb5803cb0e56b4b5f4f6f2010}} 
\index{thread\_pool@{thread\_pool}!pop\_task@{pop\_task}}
\index{pop\_task@{pop\_task}!thread\_pool@{thread\_pool}}
\doxysubsubsection{\texorpdfstring{pop\_task()}{pop\_task()}}
{\footnotesize\ttfamily bool thread\+\_\+pool\+::pop\+\_\+task (\begin{DoxyParamCaption}\item[{std\+::function$<$ void()$>$ \&}]{task }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [private]}}



Try to pop a new task out of the queue. 


\begin{DoxyParams}{Parameters}
{\em task} & A reference to the task. Will be populated with a function if the queue is not empty. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if a task was found, false if the queue is empty. 
\end{DoxyReturn}
\mbox{\Hypertarget{classthread__pool_a3e9d8436b3eb525ae5fee597740a86f4}\label{classthread__pool_a3e9d8436b3eb525ae5fee597740a86f4}} 
\index{thread\_pool@{thread\_pool}!push\_task@{push\_task}}
\index{push\_task@{push\_task}!thread\_pool@{thread\_pool}}
\doxysubsubsection{\texorpdfstring{push\_task()}{push\_task()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename F $>$ \\
void thread\+\_\+pool\+::push\+\_\+task (\begin{DoxyParamCaption}\item[{const F \&}]{task }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Push a function with no arguments or return value into the task queue. 


\begin{DoxyTemplParams}{Template Parameters}
{\em F} & The type of the function. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em task} & The function to push. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classthread__pool_ae37f7cf895480503583a852c30947794}\label{classthread__pool_ae37f7cf895480503583a852c30947794}} 
\index{thread\_pool@{thread\_pool}!push\_task@{push\_task}}
\index{push\_task@{push\_task}!thread\_pool@{thread\_pool}}
\doxysubsubsection{\texorpdfstring{push\_task()}{push\_task()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename F , typename... A$>$ \\
void thread\+\_\+pool\+::push\+\_\+task (\begin{DoxyParamCaption}\item[{const F \&}]{task,  }\item[{const A \&...}]{args }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Push a function with arguments, but no return value, into the task queue. 

The function is wrapped inside a lambda in order to hide the arguments, as the tasks in the queue must be of type std\+::function$<$void()$>$, so they cannot have any arguments or return value. If no arguments are provided, the other overload will be used, in order to avoid the (slight) overhead of using a lambda.


\begin{DoxyTemplParams}{Template Parameters}
{\em F} & The type of the function. \\
\hline
{\em A} & The types of the arguments. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em task} & The function to push. \\
\hline
{\em args} & The arguments to pass to the function. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classthread__pool_aa5926f83dde427afac052f4d72237b18}\label{classthread__pool_aa5926f83dde427afac052f4d72237b18}} 
\index{thread\_pool@{thread\_pool}!reset@{reset}}
\index{reset@{reset}!thread\_pool@{thread\_pool}}
\doxysubsubsection{\texorpdfstring{reset()}{reset()}}
{\footnotesize\ttfamily void thread\+\_\+pool\+::reset (\begin{DoxyParamCaption}\item[{const ui32 \&}]{\+\_\+thread\+\_\+count = {\ttfamily std\+:\+:thread\+:\+:hardware\+\_\+concurrency()} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Reset the number of threads in the pool. Waits for all currently running tasks to be completed, then destroys all threads in the pool and creates a new thread pool with the new number of threads. Any tasks that were waiting in the queue before the pool was reset will then be executed by the new threads. If the pool was paused before resetting it, the new pool will be paused as well. 


\begin{DoxyParams}{Parameters}
{\em \+\_\+thread\+\_\+count} & The number of threads to use. The default value is the total number of hardware threads available, as reported by the implementation. With a hyperthreaded CPU, this will be twice the number of CPU cores. If the argument is zero, the default value will be used instead. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classthread__pool_a132ec56ca21d1517b6851ab6d798ee0f}\label{classthread__pool_a132ec56ca21d1517b6851ab6d798ee0f}} 
\index{thread\_pool@{thread\_pool}!submit@{submit}}
\index{submit@{submit}!thread\_pool@{thread\_pool}}
\doxysubsubsection{\texorpdfstring{submit()}{submit()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename F , typename... A, typename  = std\+::enable\+\_\+if\+\_\+t$<$std\+::is\+\_\+void\+\_\+v$<$std\+::invoke\+\_\+result\+\_\+t$<$std\+::decay\+\_\+t$<$\+F$>$, std\+::decay\+\_\+t$<$\+A$>$...$>$$>$$>$$>$ \\
std\+::future$<$ bool $>$ thread\+\_\+pool\+::submit (\begin{DoxyParamCaption}\item[{const F \&}]{task,  }\item[{const A \&...}]{args }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Submit a function with zero or more arguments and no return value into the task queue, and get an std\+::future$<$bool$>$ that will be set to true upon completion of the task. 


\begin{DoxyTemplParams}{Template Parameters}
{\em F} & The type of the function. \\
\hline
{\em A} & The types of the zero or more arguments to pass to the function. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em task} & The function to submit. \\
\hline
{\em args} & The zero or more arguments to pass to the function. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A future to be used later to check if the function has finished its execution. 
\end{DoxyReturn}
\mbox{\Hypertarget{classthread__pool_a57c26beb0b0f6985b72ab98317ce9b09}\label{classthread__pool_a57c26beb0b0f6985b72ab98317ce9b09}} 
\index{thread\_pool@{thread\_pool}!submit@{submit}}
\index{submit@{submit}!thread\_pool@{thread\_pool}}
\doxysubsubsection{\texorpdfstring{submit()}{submit()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename F , typename... A, typename R  = std\+::invoke\+\_\+result\+\_\+t$<$std\+::decay\+\_\+t$<$\+F$>$, std\+::decay\+\_\+t$<$\+A$>$...$>$, typename  = std\+::enable\+\_\+if\+\_\+t$<$!std\+::is\+\_\+void\+\_\+v$<$\+R$>$$>$$>$ \\
std\+::future$<$ R $>$ thread\+\_\+pool\+::submit (\begin{DoxyParamCaption}\item[{const F \&}]{task,  }\item[{const A \&...}]{args }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Submit a function with zero or more arguments and a return value into the task queue, and get a future for its eventual returned value. 


\begin{DoxyTemplParams}{Template Parameters}
{\em F} & The type of the function. \\
\hline
{\em A} & The types of the zero or more arguments to pass to the function. \\
\hline
{\em R} & The return type of the function. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em task} & The function to submit. \\
\hline
{\em args} & The zero or more arguments to pass to the function. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A future to be used later to obtain the function\textquotesingle{}s returned value, waiting for it to finish its execution if needed. 
\end{DoxyReturn}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/home/mspronesti/\+Desktop/baylib/baylib/tools/threads/\mbox{\hyperlink{thread__pool_8hpp}{thread\+\_\+pool.\+hpp}}\end{DoxyCompactItemize}
